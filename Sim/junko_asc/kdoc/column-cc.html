<HTML>
<HEAD><TITLE>./kdoc/column-cc</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<PRE>#include &quot;simeb.h&quot;

#define ERROR_NOLEFTBRACE   &quot;simeb: Missing '{'.&quot;
#define ERROR_NORGHTBRACE   &quot;simeb: Missing '}'.&quot;
#define ERROR_NOARG         &quot;simeb: Error: Missing argument.&quot;
#define ERROR_UNKNOWN       &quot;simeb: Error: Unknown token.&quot;

real const Column::rPrecision = 1.0e-6;
real const Column::iMaxSections = 50;

int        Column::iNumPlanes = 0;    // Total number of defined planes.
TPlane **  Column::Planes = NULL;     // Array of pointers to planes.
real       Column::rCapture = 0.0;    // Minimum flatness of a plane.

void Column::Setup(void)
{
  Planes = new (TPlane *)[iMaxSections];
}

void Column::Parse(TParser &parser, char *s_token)
{
  if (!strcmp(s_token, &quot;Source&quot;))
    Planes[iNumPlanes++] = TSource::Parse(parser);

  else if (!strcmp(s_token, &quot;Plane&quot;))
    Planes[iNumPlanes++] = TPlane::Parse(parser);

  ///////////////////////////////////////////////////////////////
  // If none of the known commands have been matched yet, the
  // token should be the name of a defined plane, and the rest
  // of the command should be redirected to the appropriate plane.
  // The following loop searches for the a plane name matching
  // the token and if one is found, redirects the command to
  // that plane.
  else {
    TPlane * plane = NULL;
    for (int i = 0; i &lt; iNumPlanes; ++i)
      if (!strcmp(s_token, Planes[i]-&gt;sGetName()))
	  plane = Planes[i];
    if (!plane) parser.Error();

    parser &gt;&gt; s_token;
    if (parser.Eof()) parser.Error();
    plane-&gt;Parse(parser, s_token);
  }
}


void Column::Initialize(void)
{
  /////////////////////////////////////////////////////////////
  // 4. Initialize each plane.

  // During the parsing phase, each plane may have processed an
  // &quot;Electrode&quot; statement specifying the voltage at that plane.
  for (int i = 0; i &lt; iNumPlanes-1; ++i)
    Planes[i+1]-&gt;rSetVoltage(Planes[i]-&gt;rGetVoltage());

  for (int i = 0; i &lt; iNumPlanes-1; ++i) {
    real r_vi = 
      Relativity::rCalcVelocity(Planes[i]-&gt;rGetVoltage());
    real r_vf = 
      Relativity::rCalcVelocity(Planes[i+1]-&gt;rGetVoltage());

    real r_dz = rGetZ(i+1) - rGetZ(i);
    if (r_dz &gt; 0.0) 
      Planes[i]-&gt;rSetFieldA(0.5 * (r_vf*r_vf - r_vi*r_vi) / r_dz);
  }

  // rCapture records how close a particle must be to a plane to cross
  // that plane.
  rCapture = rPrecision * (Planes[iNumPlanes-1]-&gt;rGetZ() - Planes[0]-&gt;rGetZ());

  // Allow each plane to initialize itself.
  for (int i = 0; i &lt; iNumPlanes; ++i) Planes[i]-&gt;Initialize();
}
</PRE>
<HR>
<address>Documentation generated by ktaka@junko on Thu Dec 16 18:04:15 PST 1999
</address>
</BODY>
</HTML>
