<HTML>
<HEAD><TITLE>./kdoc/plane-cc</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<PRE>#include &quot;simeb.h&quot;

int  TPlane::iPlaneCounter = 0;
bool TPlane::bRayTrace = false;

TPlane * TPlane::Parse(TParser &parser)
{
  TPlane * plane = NULL;
  char s_token[MAX_TOKEN];

  parser &gt;&gt; s_token;
  if (!strcmp(s_token, &quot;Target&quot;)) plane = new TTarget();
  if (!strcmp(s_token, &quot;Aperture&quot;)) plane = new TAperture();
  if (!strcmp(s_token, &quot;ThinLens&quot;)) plane = new TThinLens();
  if (!strcmp(s_token, &quot;EELens&quot;)) plane = new EELens();
  if (!plane) parser.Error();

  parser &gt;&gt; s_token;
  if (strcmp(s_token, &quot;{&quot;)) parser.Error();

  for (;;) {
    parser &gt;&gt; s_token;
    if (parser.Eof()) parser.Error();
    if (!strcmp(s_token, &quot;}&quot;)) break;
    plane-&gt;Parse(parser, s_token);
  }
  return plane;
}

// Generic plane constructor.
TPlane::TPlane(void)
{
  iPlane = TPlane::iPlaneCounter++;

  *sName = 0;
  rZ = 0.0;

  iGroup = 0;
  iSetGroup = 0;
  iClearGroup = 0;

  bVoltageSpec = false;
  rVoltage = 0.0;
}


void TPlane::Parse(TParser &parser, char *s_token)
{
  // Read in parameters.
  if (!strcmp(s_token, &quot;Name&quot;)) parser &gt;&gt; sName;
  else if (!strcmp(s_token, &quot;Z&quot;)) parser &gt;&gt; rZ;
  else if (!strcmp(s_token, &quot;Electrode&quot;))
    {parser &gt;&gt; rVoltage; bVoltageSpec = true;}
  else if (!strcmp(s_token, &quot;Group&quot;)) parser &gt;&gt; iGroup;
  else if (!strcmp(s_token, &quot;SetGroup&quot;)) parser &gt;&gt; iSetGroup;
  else if (!strcmp(s_token, &quot;ClearGroup&quot;)) parser &gt;&gt; iClearGroup;
  else if (!strcmp(s_token, &quot;RayTrace&quot;)) {parser &gt;&gt; bRayTrace;}
  else parser.Error();
}

void TPlane::Initialize(void)
{
}

// Dump particle information to the output file.
bool TPlane::Cross(Particle * const p)
{
  if (bRayTrace) if (!(p-&gt;iGetGroup() & ~iGroup))
    cout &lt;&lt; p-&gt;xyzP.rZ &lt;&lt; space
         &lt;&lt; p-&gt;xyzP.rX &lt;&lt; space
	 &lt;&lt; p-&gt;xyzP.rY &lt;&lt; space
	 &lt;&lt; p-&gt;xyzV.rX / p-&gt;xyzV.rZ &lt;&lt; space
	 &lt;&lt; p-&gt;xyzV.rY / p-&gt;xyzV.rZ &lt;&lt; newline;

  return true;
}

void TPlane::Trajectory(Particle * p, TXY const & xy_v_normal)
{
  p-&gt;xyzV.rZ = sqrt(p-&gt;xyzV * p-&gt;xyzV) / sqrt(1 + xy_v_normal*xy_v_normal);

  p-&gt;xyzV.rX = xy_v_normal.rX * p-&gt;xyzV.rZ;
  p-&gt;xyzV.rY = xy_v_normal.rY * p-&gt;xyzV.rZ;
}

TTarget::TTarget() : TPlane()
{
  TargetFile = NULL;

  iNumParticles = 0;
  iTotalParticles = 0;
  iNumTrailers = 0;
}


void TTarget::Parse(TParser &parser, char * s_token)
{
  if (!strcmp(s_token, &quot;Trailers&quot;)) parser &gt;&gt; iNumTrailers;
  else TPlane::Parse(parser, s_token);
}

void TTarget::Initialize(void)
{
  TPlane::Initialize();

  iTotalParticles = TSource::iGetTotalParticles();

  char s_filename[MAX_TOKEN];
  strcpy(s_filename, SimEB::sGetName());
  strcat(s_filename, &quot;.&quot;);

  if (*sGetName()) strcat(s_filename, sGetName());
  else strcat(s_filename, &quot;target&quot;);

  // Change by ktaka starts here.
  strcpy(out_filename, s_filename);
  cout &lt;&lt; out_filename &lt;&lt; endl;

  ofstream outfile(out_filename);
  if (!outfile) cerr &lt;&lt; out_filename &lt;&lt; &quot; read open error.&quot; &lt;&lt; endl;

//  TargetFile = fopen(s_filename, &quot;wb&quot;);
//  if (!TargetFile) {
//    fprintf(stderr, &quot;Cannot open file %s.\n&quot;, s_filename);
//   exit(0);
//  }
  // Change by ktaka ends here.
}

bool TTarget::Cross(Particle * const p)
{
  bool b = TPlane::Cross(p);

  ++iNumParticles;
  if (iNumParticles-1 &lt; iNumTrailers) return b;
  if (iTotalParticles - iNumParticles &lt; iNumTrailers) return b;
  if (p-&gt;iGetGroup() & ~iGroup) return b;

  int i;
  float f;

  // Change by ktaka starts here.
  ofstream outfile(out_filename,ios::app);
  if (!outfile) cerr &lt;&lt; out_filename &lt;&lt; &quot; read open error.&quot; &lt;&lt; endl;

  outfile &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(10) &lt;&lt; p-&gt;iGetId();
  outfile &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(5) &lt;&lt; p-&gt;iGetBeam();
  outfile &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10) ;
  outfile &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(15) &lt;&lt; p-&gt;xyzP.rX;
  outfile &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(15) &lt;&lt; p-&gt;xyzP.rY;
  outfile &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(15) &lt;&lt; -1*p-&gt;xyzP.rZ;
  outfile &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(5) ;
  outfile &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(15) &lt;&lt; p-&gt;xyzV.rX;
  outfile &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(15) &lt;&lt; p-&gt;xyzV.rY;
  outfile &lt;&lt; setiosflags(ios::left) &lt;&lt; setw(15) &lt;&lt; p-&gt;xyzV.rZ &lt;&lt; endl;
  
//  i = p-&gt;iGetId(); fwrite(&i, sizeof(i), 1, TargetFile);
//  i = p-&gt;iGetBeam(); fwrite(&i, sizeof(i), 1, TargetFile);

//  f = p-&gt;xyzP.rX; fwrite(&f, sizeof(f), 1, TargetFile);
//  f = p-&gt;xyzP.rY; fwrite(&f, sizeof(f), 1, TargetFile);

//  f = p-&gt;xyzV.rX; fwrite(&f, sizeof(f), 1, TargetFile);
//  f = p-&gt;xyzV.rY; fwrite(&f, sizeof(f), 1, TargetFile);
//  f = p-&gt;xyzV.rZ; fwrite(&f, sizeof(f), 1, TargetFile);
  // Change by ktaka ends here.

  return b;
}

void TAperture::Parse(TParser &parser, char *s_token)
{
  if (!strcmp(s_token, &quot;Shape&quot;)) Shape = TShape::Parse(parser);
  else TPlane::Parse(parser, s_token);
}

// Process a particle crossing a TAperture.
bool TAperture::Cross(Particle * const p)
{
  if (!TPlane::Cross(p)) return false;
  return Shape-&gt;bInside((TXY)p-&gt;xyzP);
}

// Create a TThinLens.
TThinLens::TThinLens(void) : TPlane()
{
  rFocalLength = 0.0;
}


// Parse arguments for TThinLens.
void TThinLens::Parse(TParser &parser, char *s_token)
{
  if (!strcmp(s_token, &quot;FocalLength&quot;)) parser &gt;&gt; rFocalLength;
  else TPlane::Parse(parser, s_token);
}

// Process a particle crossing a TThinLens.
bool TThinLens::Cross(Particle * const p)
{
  if (!TPlane::Cross(p)) return false;

  const TXY xy_p = (TXY)p-&gt;xyzP;
  const TXY xy_v = (TXY)p-&gt;xyzV;
  const TXY xy_v_normal = xy_v / p-&gt;xyzV.rZ - xy_p / rFocalLength;
  Trajectory(p, xy_v_normal);
  return true;
}

int    EELens::iMode = EELENS_OFF;
int    EELens::iGroup = 0;
FILE * EELens::pFile = NULL;
int *  EELens::LensMap = NULL;
real * EELens::CurrentMap = NULL;
int    EELens::iNumLens = 0;
int    EELens::iNumBeams = 0;
int    EELens::iNumElements = 0;
int    EELens::iNumSegments = 1;
int    EELens::iLensCounter = 0;

EELens::EELens(void) : TTarget()
{
  iLens = EELens::iLensCounter++;

  rMaxRadius = NULL;
  rStepRadius = NULL;
  LensArray = NULL;
}

void EELens::Initialize(void)
{
  if (EELens::iMode == EELENS_OFF) {
    TPlane::Initialize();
    return;
  }

  if (EELens::iMode == EELENS_TARGET) {
    sprintf(sName, &quot;eeLens.%d.target&quot;, EELens::iLens);
    TTarget::iGroup = EELens::iGroup;
    TTarget::Initialize();
    return;
  }

  TPlane::Initialize();

  EELens::LensMap[iLens] = iGetPlane();

  LensAxis = new TXY[iNumBeams];
  rMaxRadius = new real[iNumBeams];
  rStepRadius = new real[iNumBeams];
  LensArray = new real *[iNumBeams];

  real r_velocity = Relativity::rCalcVelocity(rGetVoltage());

  for (int i = 0; i &lt; iNumBeams; ++i) {
    float f1, f2, f3;
    fscanf(EELens::pFile, &quot;%f %f %f&quot;, &f1, &f2, &f3);
    LensAxis[i].rX = f1;
    LensAxis[i].rY = f2;
    rMaxRadius[i] = f3;
    rStepRadius[i] = rMaxRadius[i] / iNumElements;

    real r_current = EELens::CurrentMap[i];
    real r_scale = SimEB::rGetQM() * r_current / r_velocity;

    LensArray[i] = new real[iNumElements+1];
    LensArray[i][0] = 0.0;
    for (int j = 1; j &lt;= iNumElements; ++j) {
      float f;
      fscanf(EELens::pFile, &quot;%f&quot;, &f);
      LensArray[i][j] = ((real)f) * r_scale;
    }
  }
}

bool EELens::Cross(Particle * const p)
{
  if (EELens::iMode == EELENS_OFF) return TPlane::Cross(p);
  if (EELens::iMode == EELENS_TARGET) return TTarget::Cross(p);

  if (!TPlane::Cross(p)) return false;

  TXY const xy_p0 = (TXY)p-&gt;xyzP;
  TXY const xy_v0 = (TXY)p-&gt;xyzV;

  TXY xy_dp = xy0;
  TXY xy_dv = xy0;

  if (iLens &gt; 0) {
    EELens * eelens = (EELens *)Column::GetPlane(EELens::LensMap[iLens-1]);

    real const r_dt = (rGetZ() - eelens-&gt;rGetZ()) / 2 / p-&gt;xyzV.rZ;
    real const r_dt1 = r_dt / iNumSegments;
    real const r_dt2 = r_dt1 * r_dt1 / 2;
    real const r_dt3 = r_dt2 * r_dt1 / 3;

    if (r_dt &gt; 0.0) for (int i = -iNumSegments; i &lt; 0; ++i) {
      TXY const xy_p1 = xy_p0 + i * r_dt1 * xy_v0;
      real r_mix1 = - ((real)i) / (2 * iNumSegments);
      TXY const xy_a1 = r_mix1       * eelens-&gt;LensLookup(xy_p1) +
	                (1.0-r_mix1) * LensLookup(xy_p1);

      TXY const xy_p2 = xy_p0 + (i+1) * r_dt1 * xy_v0;
      real r_mix2 = - ((real)(i+1)) / (2 * iNumSegments);
      TXY const xy_a2 = r_mix2       * eelens-&gt;LensLookup(xy_p2) +
                        (1.0-r_mix2) * LensLookup(xy_p2);

      TXY const xy_b = (xy_a2 - xy_a1) / r_dt1;

      xy_dp += xy_dv*r_dt1 + xy_a1*r_dt2 + xy_b*r_dt3;
      xy_dv += xy_a1*r_dt1  + xy_b*r_dt2;
    }
  }

  if (iLens &lt; EELens::iLensCounter-1) {
    EELens * eelens = (EELens *)Column::GetPlane(EELens::LensMap[iLens+1]);

    real const r_dt = (eelens-&gt;rGetZ() - rGetZ()) / 2 / p-&gt;xyzV.rZ;
    real const r_dt1 = r_dt / iNumSegments;
    real const r_dt2 = r_dt1 * r_dt1 / 2;
    real const r_dt3 = r_dt2 * r_dt1 / 3;

    if (r_dt &gt; 0.0) for (int i = 1; i &lt;= iNumSegments; ++i) {
      TXY const xy_p1 = xy_p0 + (i-1) * r_dt1 * xy_v0;
      real r_mix1 = ((real)(i-1)) / (2 * iNumSegments);
      TXY const xy_a1 = r_mix1       * eelens-&gt;LensLookup(xy_p1) +
	                (1.0-r_mix1) * LensLookup(xy_p1);

      TXY const xy_p2 = xy_p0 + i * r_dt1 * xy_v0;
      real r_mix2 = ((real)i) / (2 * iNumSegments);
      TXY const xy_a2 = r_mix2       * eelens-&gt;LensLookup(xy_p2) +
                        (1.0-r_mix2) * LensLookup(xy_p2);

      TXY const xy_b = (xy_a2 - xy_a1) / r_dt1;

      xy_dp += xy_dv*r_dt1 + xy_a1*r_dt2 + xy_b*r_dt3;
      xy_dv += xy_a1*r_dt1  + xy_b*r_dt2;
    }

    p-&gt;xyzP -= xy_dv * r_dt;
  }

  p-&gt;xyzV += xy_dv;
  p-&gt;xyzP += xy_dp;

  return true;
}

TXY EELens::LensLookup(TXY xy_p)
{
  TXY xy_a = xy0;

  for (int i = 0; i &lt; EELens::iNumBeams; ++i) {
    TXY xy_p_rel = xy_p - LensAxis[i];
    real const r_p = sqrt(xy_p_rel * xy_p_rel);

    real r_a;
  
    if (r_p &lt; rMaxRadius[i]) {
      int const j = (int)(r_p / rStepRadius[i]);
      real const r = (r_p - j * rStepRadius[i]) / rStepRadius[i];
    
      r_a = (1-r) * LensArray[i][j] + r * LensArray[i][j+1];
    }
    else r_a = LensArray[i][iNumElements] * rMaxRadius[i] / r_p;

    if (r_p != 0.0) xy_a += xy_p_rel * (r_a / r_p);
  }

  return xy_a;
}
</PRE>
<HR>
<address>Documentation generated by ktaka@junko on Thu Dec 16 18:04:15 PST 1999
</address>
</BODY>
</HTML>
